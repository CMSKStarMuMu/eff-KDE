/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "PdfRT.h" 

ClassImp(PdfRT) 

PdfRT::PdfRT(const char *name, const char *title, 
	     RooAbsReal& _ctK,
	     RooAbsReal& _ctL,
	     RooAbsReal& _phi,
	     RooAbsReal& _Fl,
	     RooAbsReal& _P1,
	     RooAbsReal& _P2,
	     RooAbsReal& _P3,
	     RooAbsReal& _P4p,
	     RooAbsReal& _P5p,
	     RooAbsReal& _P6p,
	     RooAbsReal& _P8p,
	     RooAbsReal& _Eff,
	     std::vector<double> _intPart) :
  RooAbsPdf(name,title), 
  ctK("ctK","ctK",this,_ctK),
  ctL("ctL","ctL",this,_ctL),
  phi("phi","phi",this,_phi),
  Fl("Fl","Fl",this,_Fl),
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  P4p("P4p","P4p",this,_P4p),
  P5p("P5p","P5p",this,_P5p),
  P6p("P6p","P6p",this,_P6p),
  P8p("P8p","P8p",this,_P8p),
  Eff("Eff","efficiency function",this,_Eff),
  intPart(_intPart)
{
}


PdfRT::PdfRT(const PdfRT& other, const char* name) :  
  RooAbsPdf(other,name), 
  ctK("ctK",this,other.ctK),
  ctL("ctL",this,other.ctL),
  phi("phi",this,other.phi),
  Fl("Fl",this,other.Fl),
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  P4p("P4p",this,other.P4p),
  P5p("P5p",this,other.P5p),
  P6p("P6p",this,other.P6p),
  P8p("P8p",this,other.P8p),
  Eff("Eff",this,other.Eff),
  intPart(other.intPart)
{
}



Double_t PdfRT::evaluate() const 
{

  double dec = ( 0.75 * (1-Fl) * (1-ctK*ctK) +
		 Fl * ctK*ctK +
		 ( 0.25 * (1-Fl) * (1-ctK*ctK) - Fl * ctK*ctK ) * ( 2 * ctL*ctL -1 ) +
		 0.5 * P1 * (1-Fl) * (1-ctK*ctK) * (1-ctL*ctL) * cos(2*phi) +
		 2 * cos(phi) * ctK * sqrt(Fl * (1-Fl) * (1-ctK*ctK)) * ( P4p * ctL * sqrt(1-ctL*ctL) + P5p * sqrt(1-ctL*ctL) ) +
		 2 * sin(phi) * ctK * sqrt(Fl * (1-Fl) * (1-ctK*ctK)) * ( P8p * ctL * sqrt(1-ctL*ctL) - P6p * sqrt(1-ctL*ctL) ) +
		 2 * P2 * (1-Fl) * (1-ctK*ctK) * ctL -
		 P3 * (1-Fl) * (1-ctK*ctK) * (1-ctL*ctL) * sin(2*phi) );
  if ( dec<1e-55 ) return 1e-55;

  double effValue = effVal()->getVal();
  if (effValue<0)  std::cout<<"ERROR! NEGATIVE EFFICIENCY SPOTTED AT ("<<ctK<<","<<ctL<<","<<phi<<"): "<<effValue<<std::endl;
  if (effValue==0) std::cout<<"ERROR! ZERO EFFICIENCY SPOTTED AT ("    <<ctK<<","<<ctL<<","<<phi<<"): "<<effValue<<std::endl;

  return (9./(32 * 3.14159265) * effValue * dec);

}

namespace {
  Bool_t fullRangeCosT(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for cosTheta variables
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() + 1.) < 1.e-5 && std::fabs(x.max() - 1.) < 1.e-5
      : std::fabs(x.min(range) + 1.) < 1.e-5 && std::fabs(x.max(range) - 1.) < 1.e-5;
  }
  Bool_t fullRangePhi(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for phi variable
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() + TMath::Pi()) < 1.e-3 && std::fabs(x.max() - TMath::Pi()) < 1.e-3
      : std::fabs(x.min(range) + TMath::Pi()) < 1.e-3 && std::fabs(x.max(range) - TMath::Pi()) < 1.e-3;
  }
}

Int_t PdfRT::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
  // use pre-computed integrals for the integration over all the three variables
  // after checking that integrals are in place
  if ( intPart.size()<1 || intPart[0]==0 )
    return 0 ;
  if ( matchArgs(allVars,analVars,ctK,ctL,phi) )
    if ( fullRangeCosT(ctK,rangeName) && fullRangeCosT(ctL,rangeName) && fullRangePhi(phi,rangeName) )
      return 1 ;

  // the lack of analytical integral for the subsets of angular variables does not slow down the fit
  // since only the complete integration is used there
  // if one wants to speed up also the PDF projection for plotting, the other analytical integrals can be computed
  // but it seems a huge effort to me
  return 0 ;

}

Double_t PdfRT::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code>0 && code<2) ;

  // use the pre-computed integrals from histogram
  Double_t ret =  9./(32*3.14159265) * (
					0.75*(1-Fl)              * intPart[0]
					+ Fl                     * intPart[1]
					+ 0.25*(1-Fl)            * intPart[2]
					- Fl                     * intPart[3]
					+ 0.5*P1*(1-Fl)          * intPart[4]
					+ 0.5*sqrt(Fl-Fl*Fl)*P4p * intPart[5]
					+ sqrt(Fl-Fl*Fl)*P5p     * intPart[6]
					- sqrt(Fl-Fl*Fl)*P6p     * intPart[7]
					+ 0.5*sqrt(Fl-Fl*Fl)*P8p * intPart[8]
					+ 2*(1-Fl)*P2            * intPart[9]
					- P3*(1-Fl)              * intPart[10]
					);

  if (ret<=0) {
    if (ret<0) std::cout<<"ERROR! Negative pdf integral, fake value returned"<<std::endl;
    else std::cout<<"ERROR! Null pdf integral, fake value returned"<<std::endl;
    return 1e-55;
  }
 
  return ret ;

}
